{"ast":null,"code":"function _objectEntries(obj) {\n  var entries = [];\n  var keys = Object.keys(obj);\n  for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);\n  return entries;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport React from \"react\";\nimport { useImgixContext } from \"../HOCs\";\n\n/**\n * Merges the `src` object into the `destination` object. Destination values are\n * not overwritten by source values. Destination properties that resolve to\n * `undefined` or `null` are not overwritten if a destination value exists\n * unless destination key does not exist . It recursively merges the\n * `imgixParams` and `htmlAttributes` values.\n *\n * @param {Object} src - The Provider component's props object\n * @param {Object} destination - The child component's props object\n * @returns Object with the combined values from `src` & `destination` Objects\n *\n * @example\n *  const src = {\n *    width: 100,\n *    height: 200,\n *    imgixParams: { ar: \"1:2\", dpr: 2},\n *    htmlAttributes: { styles: \"width: 50\" }\n *  }\n *  const destination = {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *  const result = mergeProps(src, destination);\n *\n *  {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { ar: \"1:2\", dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *\n */\nexport var mergeProps = function mergeProps(src, destination) {\n  if (src == null && destination !== null) {\n    return destination;\n  }\n  if (src !== null && destination == null) {\n    return src;\n  }\n  if (src == null && destination == null) {\n    return {};\n  }\n  var newProps = _objectSpread({}, destination);\n  var newPropKeys = Object.keys(newProps);\n  for (var _i = 0, _Object$entries = _objectEntries(src); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      k = _Object$entries$_i[0],\n      v = _Object$entries$_i[1];\n    if (newPropKeys.indexOf(k) == -1 && v !== null) {\n      newProps[k] = v;\n    }\n    // recursively merge imgixParams and htmlAttributes\n    if (k === \"imgixParams\" || k === \"htmlAttributes\") {\n      if (v !== null) {\n        newProps[k] = mergeProps(src[k], newProps[k]);\n      }\n    }\n  }\n  return newProps;\n};\n\n/**\n * `mergeComponentPropsHOF` tries to invoke `React.useContext()`. If context is\n * `undefined`, context is being accessed outside of an `ImgixContext` provider\n * and the Component is returned as is.\n *\n * Otherwise, it merges a Component's props with the `ImgixContext` props and\n * return a Component with the merged `props`.\n * @param {React.Element <typeof Component} Component -  with defined `props`.\n * @returns Component with merged `props`.\n */\nexport var mergeComponentPropsHOF = function mergeComponentPropsHOF(Component) {\n  return function mergeComponentPropsHOFInner(props) {\n    var contextProps = useImgixContext();\n    if (contextProps == null) {\n      return /*#__PURE__*/React.createElement(Component, props);\n    }\n    var childProps = mergeProps(contextProps, props);\n    return /*#__PURE__*/React.createElement(Component, childProps);\n  };\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,eAAe,QAAQ,SAAS;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAU,CAAIC,GAAG,EAAEC,WAAW,EAAK;EAC9C,IAAID,GAAG,IAAI,IAAI,IAAIC,WAAW,KAAK,IAAI,EAAE;IACvC,OAAOA,WAAW;EACpB;EACA,IAAID,GAAG,KAAK,IAAI,IAAIC,WAAW,IAAI,IAAI,EAAE;IACvC,OAAOD,GAAG;EACZ;EACA,IAAIA,GAAG,IAAI,IAAI,IAAIC,WAAW,IAAI,IAAI,EAAE;IACtC,OAAO,CAAC,CAAC;EACX;EAEA,IAAMC,QAAQ,qBAAQD,WAAW,CAAE;EACnC,IAAME,WAAW,GAAGC,MAAM,CAACC,IAAI,CAACH,QAAQ,CAAC;EAEzC,mCAAqBI,eAAeN,GAAG,CAAC,qCAAE;IAArC;MAAOO,CAAC;MAAEC,CAAC;IACd,IAAIL,WAAW,CAACM,OAAO,CAACF,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIC,CAAC,KAAK,IAAI,EAAE;MAC9CN,QAAQ,CAACK,CAAC,CAAC,GAAGC,CAAC;IACjB;IACA;IACA,IAAID,CAAC,KAAK,aAAa,IAAIA,CAAC,KAAK,gBAAgB,EAAE;MACjD,IAAIC,CAAC,KAAK,IAAI,EAAE;QACdN,QAAQ,CAACK,CAAC,CAAC,GAAGR,UAAU,CAACC,GAAG,CAACO,CAAC,CAAC,EAAEL,QAAQ,CAACK,CAAC,CAAC,CAAC;MAC/C;IACF;EACF;EACA,OAAOL,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMQ,sBAAsB,GAAG,SAAzBA,sBAAsB,CAAIC,SAAS;EAAA,OAC9C,SAASC,2BAA2B,CAACC,KAAK,EAAE;IAC1C,IAAMC,YAAY,GAAGhB,eAAe,EAAE;IACtC,IAAIgB,YAAY,IAAI,IAAI,EAAE;MACxB,oBAAOjB,oBAACc,SAAS,EAAKE,KAAK,CAAI;IACjC;IAEA,IAAME,UAAU,GAAGhB,UAAU,CAACe,YAAY,EAAED,KAAK,CAAC;IAClD,oBAAOhB,oBAACc,SAAS,EAAKI,UAAU,CAAI;EACtC,CAAC;AAAA","names":["React","useImgixContext","mergeProps","src","destination","newProps","newPropKeys","Object","keys","_objectEntries","k","v","indexOf","mergeComponentPropsHOF","Component","mergeComponentPropsHOFInner","props","contextProps","childProps"],"sources":["C:\\Users\\chels\\CS494\\Forms-of-Migration-Website\\node_modules\\react-imgix\\src\\HOFs\\propMerger.js"],"sourcesContent":["import React from \"react\";\nimport { useImgixContext } from \"../HOCs\";\n\n/**\n * Merges the `src` object into the `destination` object. Destination values are\n * not overwritten by source values. Destination properties that resolve to\n * `undefined` or `null` are not overwritten if a destination value exists\n * unless destination key does not exist . It recursively merges the\n * `imgixParams` and `htmlAttributes` values.\n *\n * @param {Object} src - The Provider component's props object\n * @param {Object} destination - The child component's props object\n * @returns Object with the combined values from `src` & `destination` Objects\n *\n * @example\n *  const src = {\n *    width: 100,\n *    height: 200,\n *    imgixParams: { ar: \"1:2\", dpr: 2},\n *    htmlAttributes: { styles: \"width: 50\" }\n *  }\n *  const destination = {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *  const result = mergeProps(src, destination);\n *\n *  {\n *    width: 101,\n *    height: 201,\n *    imgixParams: { ar: \"1:2\", dpr: 1 },\n *    htmlAttributes: { styles: \"width: 100\" }\n *  }\n *\n */\nexport const mergeProps = (src, destination) => {\n  if (src == null && destination !== null) {\n    return destination;\n  }\n  if (src !== null && destination == null) {\n    return src;\n  }\n  if (src == null && destination == null) {\n    return {};\n  }\n\n  const newProps = { ...destination };\n  const newPropKeys = Object.keys(newProps);\n\n  for (const [k, v] of Object.entries(src)) {\n    if (newPropKeys.indexOf(k) == -1 && v !== null) {\n      newProps[k] = v;\n    }\n    // recursively merge imgixParams and htmlAttributes\n    if (k === \"imgixParams\" || k === \"htmlAttributes\") {\n      if (v !== null) {\n        newProps[k] = mergeProps(src[k], newProps[k]);\n      }\n    }\n  }\n  return newProps;\n};\n\n/**\n * `mergeComponentPropsHOF` tries to invoke `React.useContext()`. If context is\n * `undefined`, context is being accessed outside of an `ImgixContext` provider\n * and the Component is returned as is.\n *\n * Otherwise, it merges a Component's props with the `ImgixContext` props and\n * return a Component with the merged `props`.\n * @param {React.Element <typeof Component} Component -  with defined `props`.\n * @returns Component with merged `props`.\n */\nexport const mergeComponentPropsHOF = (Component) =>\n  function mergeComponentPropsHOFInner(props) {\n    const contextProps = useImgixContext();\n    if (contextProps == null) {\n      return <Component {...props} />;\n    }\n\n    const childProps = mergeProps(contextProps, props);\n    return <Component {...childProps} />;\n  };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}